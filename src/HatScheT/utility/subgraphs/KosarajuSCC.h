/*
    This file is part of the HatScheT project, developed at University of Kassel and TU Darmstadt, Germany
    Author: Patrick Sittel (sittel@uni-kassel.de)
            Benjamin Lagershausen-Kessler (benjaminkessler@student.uni-kassel.de)

    Copyright (C) 2019

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/
#ifndef HATSCHET_KOSARAJUSCC_H
#define HATSCHET_KOSARAJUSCC_H

#include <iostream>
#include <list>
#include <stack>
#include <vector>

#include "HatScheT/Graph.h"
#include "HatScheT/utility/subgraphs/SCC.h"

namespace HatScheT {

  /*
   * M. Sharir; "A strong-connectivity algorithm and its applications in data flow analysis";
   * in Computers & Mathematics with Applications; 1981
   *
   * this algorithm was later credited to Kosaraju
   *
   */
  class KosarajuSCC {
  public:

    /*!
     * \brief Constructor for this class, it needs a graph, and is used to find the SCCs in this graph.
     * \param Parameter g is the graph, in which we want to find Strongly Connected Components.
     */
    explicit KosarajuSCC(Graph& g);

    /*!
    * \brief This method performs a recursive deep first seach on the Vertices of graph g and fills a stack with the
    * with the Vertices for with the deep first search is finished in reversed order of the finish times.
    * \param Parameter V is a vertex-pointer which points to the vertex where the DFS starts.
    */
    void fillStack(Vertex* V);

    /*!
    * \brief The dfs function performes a DFS on vertex V. The Function is almost similar to the fillStack function. But
    * this time, we do not fill a stack with the Vertices.
    * \param Parameter V is a vertex-pointer which points to the vertex where the DFS starts.
    */
    void dfs(Vertex* V);

    /*!
    * \brief GetSCCs() is the main function of this class. It finds stongly connected component of graph g. At this
    * moment it will store the Vertices which are stronly connected in a vector called scc. The vector scc itself is
    * will be a component of the vector sccs which contains all the strongly connected components of graph g.
    */
    vector <SCC*> getSCCs();

    /*!
    * \brief Since the SCCs are found in the transposed graph getOriginalVertex() uses the map, generated by
    * transposeGraph() to map the SCCs to the Vertices in the original graph g.
    */
    Vertex* getOriginalVertex(Vertex* V);

    void setQuiet(bool b=true) {this->quiet = b;}

  private:

    /*!
     * Graph in which SCCs are searched.
     */
    Graph* g;

    /*!
     * Tranposed Graph of g
     */
    Graph* gT; //Transposed Graph

    /*!
     * Mappings between the Vertices of g and gT.
     */
    map <Vertex*, Vertex*> VertexMap;

    /*!
     * Information if a Vertex is already visited, used in DFS.
     */
    map <Vertex*, bool> visited;

    /*!
     * Stack of Vertices, in order of the finish time of the first DFS.
     */
    stack <Vertex*> Stack;

    /*!
     * Vector of all SCCs contained in Graph g.
     */
    vector <SCC*> sccVector;

    /*!
     * Just tells this class to SHUT UP!!!
     */
    bool quiet;

  };

}
#endif //HATSCHET_KOSARAJUSCC_H
